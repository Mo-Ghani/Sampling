


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.5.0">
    
    
      
        <title>Solar Cycle Analysis with Zeus and Nestle - Demonstrations of MCMC and Nested Samplers</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.b5d04df8.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#using-zeus-and-nestle-to-model-the-sunspot-cycles" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="Demonstrations of MCMC and Nested Samplers" class="md-header-nav__button md-logo" aria-label="Demonstrations of MCMC and Nested Samplers">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            Demonstrations of MCMC and Nested Samplers
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              Solar Cycle Analysis with Zeus and Nestle
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Demonstrations of MCMC and Nested Samplers" class="md-nav__button md-logo" aria-label="Demonstrations of MCMC and Nested Samplers">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Demonstrations of MCMC and Nested Samplers
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../PyMC3_GRS/PyMC3_GRS/" title="Gamma-Ray Spectroscopy with PyMC3 and dynesty" class="md-nav__link">
      Gamma-Ray Spectroscopy with PyMC3 and dynesty
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../LightCurve/LightCurve/" title="Exoplanet Light Curve Analysis with emcee and UltraNest" class="md-nav__link">
      Exoplanet Light Curve Analysis with emcee and UltraNest
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Solar Cycle Analysis with Zeus and Nestle
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2z"/></svg>
        </span>
      </label>
    
    <a href="./" title="Solar Cycle Analysis with Zeus and Nestle" class="md-nav__link md-nav__link--active">
      Solar Cycle Analysis with Zeus and Nestle
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#useful-imports" class="md-nav__link">
    Useful imports
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#viewing-the-data" class="md-nav__link">
    Viewing the data
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-model" class="md-nav__link">
    The model
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modelling-with-zeus" class="md-nav__link">
    Modelling with Zeus
  </a>
  
    <nav class="md-nav" aria-label="Modelling with Zeus">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sampling-the-data" class="md-nav__link">
    Sampling the data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    Results
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plotting-the-posterior" class="md-nav__link">
    Plotting the posterior
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predicting-the-next-solar-cycles" class="md-nav__link">
    Predicting the next solar cycles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predictions" class="md-nav__link">
    Predictions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modelling-with-nestle" class="md-nav__link">
    Modelling with Nestle
  </a>
  
    <nav class="md-nav" aria-label="Modelling with Nestle">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sampling-the-data_1" class="md-nav__link">
    Sampling the data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results_1" class="md-nav__link">
    Results
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plotting-the-posterior_1" class="md-nav__link">
    Plotting the posterior
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../../gravwaves/gravwaves/" title="Gravitational Wave parameter estimation with bilby" class="md-nav__link">
      Gravitational Wave parameter estimation with bilby
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#useful-imports" class="md-nav__link">
    Useful imports
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#viewing-the-data" class="md-nav__link">
    Viewing the data
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#the-model" class="md-nav__link">
    The model
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modelling-with-zeus" class="md-nav__link">
    Modelling with Zeus
  </a>
  
    <nav class="md-nav" aria-label="Modelling with Zeus">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sampling-the-data" class="md-nav__link">
    Sampling the data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results" class="md-nav__link">
    Results
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plotting-the-posterior" class="md-nav__link">
    Plotting the posterior
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predicting-the-next-solar-cycles" class="md-nav__link">
    Predicting the next solar cycles
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predictions" class="md-nav__link">
    Predictions
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modelling-with-nestle" class="md-nav__link">
    Modelling with Nestle
  </a>
  
    <nav class="md-nav" aria-label="Modelling with Nestle">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sampling-the-data_1" class="md-nav__link">
    Sampling the data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#results_1" class="md-nav__link">
    Results
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#plotting-the-posterior_1" class="md-nav__link">
    Plotting the posterior
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <h1 id="using-zeus-and-nestle-to-model-the-sunspot-cycles">Using Zeus and Nestle to model the sunspot cycles</h1>
<p>A sunspot is an area on the surface of the sun that appears a lot darker than it's surroundings, caused by intense magnetic fields regulating a convection effect on the Sun's surface. Humanity has been tracking the average number of sunspots visible from Earth on the solar disk, and found that the sunspot number follows a cycle over roughly 11 years. </p>
<p>In this example, I'll use the "Zeus" and "Nestle" samplers to fit a model describing the sunspot number to a single solar cycle. I'll then use this model to create a new model which predicts the properties of a solar cycle, given the properties of the previous cycle.</p>
<h2 id="useful-imports">Useful imports</h2>
<pre><code class="python"># numpy
import numpy as np

# pandas
import pandas as pd

# scipy
from scipy.signal import find_peaks
from scipy.stats import gaussian_kde
from scipy import integrate
from scipy.special import ndtri, gammaln

# Plotting
import corner

import matplotlib.pyplot as plt
%matplotlib inline

# Samplers
import zeus
print('Zeus version: {}'.format(zeus.__version__))

import nestle
print('Nestle version: {}'.format(nestle.__version__))

# misc
import logging
from time import time
</code></pre>

<pre><code>Zeus version: 1.0.7
Nestle version: 0.2.0
</code></pre>
<h2 id="viewing-the-data">Viewing the data</h2>
<p>Using Pandas, we can load the .csv file containing the average sunspot number over 24 solar cycles, since the 1750s. First I will plot the entire dataset to decide which cycles are of interest, however before plotting I'll first take the square root of the sunspot number. This is just to decrease the variance in the peak height, which will make everything a little easier when it comes to making a model that can predict the height of the next peak.</p>
<pre><code class="python">dataframe = pd.read_csv(&quot;SN_m_tot_V2.0.csv&quot;, sep=&quot;;&quot;, usecols=[2,3], header=None)
dates = list(dataframe[2])[80:]
ssn = list(dataframe[3])[80:]
sqrtssn = np.sqrt(ssn)

plt.figure(figsize=(16,3))
plt.plot(dates,sqrtssn)
plt.xlabel(&quot;Date / years&quot;)
plt.ylabel(&quot;Square Root of Sunspot Number&quot;)
plt.title(&quot;Average sunspot number from 1750-2020&quot;)
plt.show()
</code></pre>

<p><img alt="png" src="../output_6_0.png" /></p>
<p>I chose to look at the 4 solar cycles starting around the year 1924, as there seems to be a consistent (predictable!) change from peak to peak. Next, we need to take a closer look at those 4 solar cycles so that we can create a model.</p>
<pre><code class="python">start = 2020      # data point corresponding the the start of the 1924 solar cycle
period = 123      # average width of a solar cycle

fig,(ax1,ax2) = plt.subplots(1,2,figsize=(12,3))

# plot region of interest
ax1.plot(dates[start:start + 4*period],sqrtssn[start:start + 4*period])
ax1.set_xlabel(&quot;Date / years&quot;)
ax1.set_ylabel(&quot;Square Root of Sunspot Number&quot;)
ax1.set_title(&quot;Average sunspot number from 1924-1965&quot;)

# fragment the 4 solar cycles into 4 separate lists
peaks = [sqrtssn[start + i*period:start + (i+1)*period] for i in range(4)]
peaktimes = [dates[start + i*period:start + (i+1)*period] for i in range(4)]

# plot a typical solar cycle
ax2.plot(peaktimes[0],peaks[0])
ax2.set_xlabel(&quot;Date / years&quot;)
ax2.set_title(&quot;A typical solar cycle&quot;)
plt.show()
</code></pre>

<p><img alt="png" src="../output_8_0.png" /></p>
<h2 id="the-model">The model</h2>
<p>We can create the model by splitting it into two parts: the ascending region, and the descending region. To define these regions, we need to know when the cycle begins, when the cycle peaks, and when the cycle ends. We'll call these "t0", "tmax", and "t1" respectively. Next, we need to know the amplitude of the peak, which we will call "c". Finally, we need 2 more parameters which will describe how much the ascending and descending regions curve, which we will call "a1", and  "a2".</p>
<p>Using all of these, we can define our model for a single solar cycle below:</p>
<pre><code class="python">def cycle(times, c, a1, a2, t0, tmax, t1):

    # a1,a2 &gt; 1
    if a1 &lt; 1:
        a1 = 1
    if a2 &lt; 1:
        a2 = 1

    #t0 &lt; tmax &lt; t1
    if t0 &gt;= tmax:
        t0 = tmax - 1
    if t1 &lt;= tmax:
        t0 = tmax + 1

    # sunspot number as a function of time
    ssn = [c*(1-((tmax-t)/(tmax-t0))**a1) if t &lt; tmax
           else c*(1-((t-tmax)/(t1-tmax))**a2) for t in times]

    # ssn &gt; 0
    ssn_non_negative = [i if i &gt; 0 else 0.1 for i in ssn]

    return ssn_non_negative
</code></pre>

<p>I'll take the first solar cycle (starting 1924), and use some guesses for each parameter to overplot a model, just to give an idea of what the model will look like.</p>
<pre><code class="python"># plot cycle data
plt.plot(peaktimes[0],peaks[0],label=&quot;Original Data&quot;)
# plot an example model, with guessed parameters
x = np.linspace(min(peaktimes[0]),max(peaktimes[0]),300)
y = cycle(x,11,2.1,1.3,1923.5,1927.5,1935)
plt.plot(x,y,label=&quot;Example Model&quot;)

plt.xlabel(&quot;Date / years&quot;)
plt.ylabel(&quot;Square Root of Sunspot Number&quot;)
plt.title(&quot;A typical solar cycle, with an \n example model overplotted&quot;)
plt.legend()
plt.show()
</code></pre>

<p><img alt="png" src="../output_13_0.png" /></p>
<h2 id="modelling-with-zeus">Modelling with Zeus</h2>
<p>Zeus has a very simillar interface to the sampler "emcee", which uses an ensemble technique to obtain the prior distributions. The next step is defining the prior distributions for each parameter. I'll use a normal distribution for the peak amplitude "c", since it's pretty easy to eyeball. Aside from that, I'll be using uniform priors for every other parameter as they're a little trickier to guess.</p>
<pre><code class="python">nens = 100     # number of ensemble points
ndims = 6      # number of parameters

# mean and standard deviation of normal parameter priors
cmu,csig = 11,1
# lower and upper bounds of uniform parameter priors
a1min,a1max = 1,3
a2min,a2max = 1,3
t0min,t0max = 1922,1925
tmaxmin,tmaxmax = 1926,1929
t1min,t1max = 1933,1936

param_priors = []
# normal prior on c
param_priors.append(np.random.normal(cmu,csig,nens))
# uniform prior on a1
param_priors.append(np.random.uniform(a1min,a1max,nens))
# uniform prior on a2
param_priors.append(np.random.uniform(a2min,a2max,nens))
# uniform prior on t0
param_priors.append(np.random.uniform(t0min,t0max,nens))
# uniform prior on tmax
param_priors.append(np.random.uniform(tmaxmin,tmaxmax,nens))
# uniform prior on t1
param_priors.append(np.random.uniform(t1min,t1max,nens))

param_samples = np.array(param_priors).T
</code></pre>

<p>Next, we need to define a log prior, log likelihood, and log posterior. The log prior can be defined as below:</p>
<pre><code class="python">def logprior(theta):
    &quot;&quot;&quot;
    Function to return the log of the prior, given set of current parameters
    &quot;&quot;&quot;
    lprior = 0
    for i in range(len(param_priors)):
        # sum log priors from each parameter

        if i == 0:
            # normal priors
            lprior -= 0.5*((theta[i] - cmu) / csig)**2
        else:
            # uniform priors

            # set bounds
            if i == 1:
                low, up = a1min, a1max
            elif i == 2:
                low, up = a2min, a2max
            elif i == 3:
                low, up = t0min,t0max
            elif i == 4:
                low, up = tmaxmin,tmaxmax
            else:
                low, up = t1min,t1max

            # parameter must be between bounds
            if  low &lt; theta[i] &lt; up: 
                pass
            else:
                lprior = -np.inf

    return lprior
</code></pre>

<p>The log likelihood takes the form of a Poisson likelihood, since the sunspot counts are non-negative. using "lmbda" as the expected value of the cycle function, we can define the likelihood as below:</p>
<pre><code class="python">def loglike(theta, times, obs):
    &quot;&quot;&quot;
    Function to return the log likelihood, given the current parameters, dates, and sunspot counts
    &quot;&quot;&quot;
    # unpack parameters
    c_like, a1_like, a2_like, t0_like, tmax_like, t1_like = theta
    # expected value
    lmbda = np.array(cycle(times, c_like, a1_like, a2_like, t0_like, tmax_like, t1_like))
    n = len(obs)
    a = np.sum(gammaln(np.array(obs)+1))
    b = np.sum(np.array(obs) * np.log(lmbda))
    return -np.sum(lmbda) - a + b
</code></pre>

<p>Finally the log posterior is simply the sum of the log prior log likelihood:</p>
<pre><code class="python">def logposterior(theta, times, obs):
    &quot;&quot;&quot;
    Function to return the log posterior, given the log prior and log likelihood
    &quot;&quot;&quot;
    lprior = logprior(theta)
    # check log prior is finite
    if not np.isfinite(lprior):
        return -np.inf
    return lprior + loglike(theta, times, obs)
</code></pre>

<h3 id="sampling-the-data">Sampling the data</h3>
<p>Now that we've defined everything we need, we can easily run the sampling process with Zeus.</p>
<pre><code class="python"># create sampler using the first peak
sampler = zeus.sampler(nens, ndims, logposterior, args=[peaktimes[0], peaks[0]])

nburn = 500       # burn-in points
nsamples = 500    # points after burn-in

time0 = time()
sampler.run_mcmc(param_samples, nburn + nsamples)
time1 = time()

print(&quot;Time taken to sample first peak with Zeus: {} seconds&quot;.format(time1-time0))
</code></pre>

<pre><code>Initialising ensemble of 100 walkers...
Sampling progress : 100%|██████████| 1000/1000 [01:16&lt;00:00, 13.13it/s]

Time taken to sample first peak with Zeus: 76.26689600944519 seconds
</code></pre>
<h3 id="results">Results</h3>
<p>Collecting the samples after the sampling is equally simple, remembering to discard the burn-in samples at the start of the chain. We can create a corner plot, which shows the posteriors of each parameter along with contour plots describing how one parameter varies with any other:</p>
<pre><code class="python">samples_zeus = sampler.get_chain(flat=True, discard=nburn)

def plotposts(samples, labels, **kwargs):
    fig = corner.corner(samples, labels=labels, hist_kwargs={'density': True}, **kwargs)
    pos = [i*(len(labels)+1) for i in range(len(labels))]
    for axidx, samps in zip(pos, samples.T):
        kde = gaussian_kde(samps)
        xvals = fig.axes[axidx].get_xlim()
        xvals = np.linspace(xvals[0], xvals[1], 50)
        fig.axes[axidx].plot(xvals, kde(xvals), color='firebrick')

labels = ['c', 'a1', 'a2', 't0', 'tmax', 't1']
plotposts(samples_zeus, labels)
</code></pre>

<p><img alt="png" src="../output_28_0.png" /></p>
<p>Next, I'll find the means and standard deviation error on each parameter. I'll also choose random samples from the chains of each parameter, which I'll use to visualise the posteriors.</p>
<pre><code class="python">param_mu = [np.mean(samples_zeus[:,i]) for i in range(6)]
param_sig = [np.std(samples_zeus[:,i]) for i in range(6)]

nfits = 300
param_samples = [np.random.choice(samples_zeus[:,i],nfits) for i in range(6)]
post_samples = np.array(param_samples).T

print(&quot;Parameters describing the square root SSN cycle starting 1923: \n \n&quot; +
      &quot;   c = {} \u00B1 {} square root counts\n&quot;.format(param_mu[0], param_sig[0]) + 
      &quot;  a1 = {} \u00B1 {} \n&quot;.format(param_mu[1], param_sig[1]) +
      &quot;  a2 = {} \u00B1 {} \n&quot;.format(param_mu[2], param_sig[2]) +
      &quot;  t0 = {} \u00B1 {} years\n&quot;.format(param_mu[3], param_sig[3]) +
      &quot;tmax = {}  \u00B1 {} years\n&quot;.format(param_mu[4], param_sig[4]) +
      &quot;  t1 = {} \u00B1 {} years\n&quot;.format(param_mu[5], param_sig[5]))
</code></pre>

<pre><code>Parameters describing the square root SSN cycle starting 1923:

   c = 11.23419227189279 ± 0.5155512374811139 square root counts
  a1 = 2.046091218734536 ± 0.5511917043187438 
  a2 = 1.3175512464689283 ± 0.2551941095539496 
  t0 = 1923.4364606185572 ± 0.3683613113062203 years
tmax = 1927.5745437571138  ± 0.6532168763478214 years
  t1 = 1935.0535923941627 ± 0.30717761056370796 years
</code></pre>
<h3 id="plotting-the-posterior">Plotting the posterior</h3>
<p>Below I'll show two plots. The left plot will show the model produced using the mean parameters for the first peak. The right plot will show a posterior predictive plot, where the darker the colour of the plot, the higher the probabillty of the model passing through that region.</p>
<pre><code class="python">fig, (ax1,ax2) = plt.subplots(1,2,figsize=(13,3))

# mean posterior plot
ax1.plot(peaktimes[0], peaks[0])
x = np.linspace(min(peaktimes[0]), max(peaktimes[0]), 300)
y = cycle(x,*param_mu)
ax1.plot(x,y)
ax1.set_xlabel(&quot;Date / years&quot;)
ax1.set_ylabel(&quot;square root counts&quot;)
ax1.set_title(&quot;Mean posterior plot for solar cycle starting 1924&quot;)

# posterior predictive plot
x = np.linspace(min(peaktimes[0]),max(peaktimes[0]),300)
ax2.plot(peaktimes[0], peaks[0], label=&quot;Origina Data&quot;)
for i in range(len(post_samples)):
    params = post_samples[i]
    y = cycle(x,*params)
    ax2.plot(x,y,'orange',alpha=0.02, linewidth=3,label=&quot;Fitted Model&quot; if i == 0 else &quot;&quot;)
ax2.set_xlabel(&quot;Date / years&quot;)
ax2.set_title(&quot;Posterior predictive plot for SSN cycle starting 1924&quot;)
leg = ax2.legend()
for lh in leg.legendHandles: 
    lh.set_alpha(1)

plt.show()
</code></pre>

<p><img alt="png" src="../output_33_0.png" /></p>
<h3 id="predicting-the-next-solar-cycles">Predicting the next solar cycles</h3>
<p>We now know the properties of the solar cycle between 1924-1934. Next, we want to know the properties of the next three cycles in our region of interest. We could just redefine our prior distributions, and run the sampling again for each peak. Alternatively, we could create a new model which takes the current solar cycle parameters, and uses them to predict the next solar cycle. This model will only, realisticly, be able to make long range predictions if the solar cycles evolve consistently, as mentiioned above.</p>
<p>This way this model is put together is quite complicated. More details can be found <a href="https://wwwf.imperial.ac.uk/~dvandyk/Research/15-bayes.trend-solar.pdf">here</a>, but the brief is that we need 3 scaling parameters (y1,y2,y3), and 4 translation parameters (d0,d1,d2,d3). This model can be implemented as follows:</p>
<pre><code class="python">def predict_cycle(theta_prev, d0, d1, d2, d3, y1, y2, y3):
    c_prev, a1, a2, t0_prev, tmax_prev, t1_prev = theta_prev
    # start of cycle found using slight deviation d0
    t0 = t1_prev + d0
    # current c found using current t0 and previous c,tmax
    if t0 &lt;= tmax_prev:
        t0 = tmax_prev+5
    c = y1*c_prev/(t0 - tmax_prev) + d1
    # current tmax found using current t0,c
    tmax = t0 + y2*c + d2*(t0-param_mu[4])**0.9
    # current t1 found using current tmax,c
    t1 = tmax + y3*c + d3*(t0-param_mu[4])**0.3
    #a1,a2 unchanged
    # return new set of parameters
    theta_new = (c,a1,a2,t0,tmax,t1)
    return theta_new
</code></pre>

<p>We can now try to guess the scaling and translational parameters, and using the set of parameters defining the first solar cycle, we can try to predict the second solar cycle between 1934-1944. I'll show this by plotting the data for the second solar cycle, and overplotting the predicted model. After some trial and error, I found the following prediction:</p>
<pre><code class="python"># predict the next peak parameters, using current peak parameters
params = predict_cycle(param_mu,-1,0,-0.4,0.2,7.5,0.5,0.5)
# plot second solar cycle
plt.plot(peaktimes[1],peaks[1],label=&quot;Original Data&quot;)
# overplot predicted model with new parameters
x = np.linspace(min(peaktimes[1]),max(peaktimes[1]),300)
plt.plot(x,cycle(x,*params),label=&quot;Predicted model&quot;)
plt.xlabel(&quot;Date / years&quot;)
plt.ylabel(&quot;Square Root of Sunspot Number&quot;)
plt.title(&quot;Average square root sunspot number between 1934-1944 \n with overplotted predicted model&quot;)
plt.legend()
plt.show()
</code></pre>

<p><img alt="png" src="../output_38_0.png" /></p>
<p>Using the above guesses, we can define some prior distributions. This is done in exactly the same way as above, however due to some hard limits on the parameters (such as a1,a2 being strictly greater than 1), I'll use uniform priors for all parameters.</p>
<pre><code class="python">nens = 100
ndims = 7

d0min,d0max = -2.,0
d1min,d1max = -1.,1.
d2min,d2max = -1.,0.
d3min,d3max = 0.,0.4
y1min,y1max = 7.,8.
y2min,y2max = 0.2,0.8
y3min,y3max = 0.25,0.75

predict_priors = []
# uniform prior on d0
predict_priors.append(np.random.uniform(d0min,d0max,nens))
# uniform prior on d1
predict_priors.append(np.random.uniform(d1min,d1max,nens))
# uniform prior on d2
predict_priors.append(np.random.uniform(d2min,d2max,nens))
# uniform prior on d3
predict_priors.append(np.random.uniform(d3min,d3max,nens))
# uniform prior on y1
predict_priors.append(np.random.uniform(y1min,y1max,nens))
# uniform prior on y2
predict_priors.append(np.random.uniform(y2min,y2max,nens))
# uniform prior on y3
predict_priors.append(np.random.uniform(y3min,y3max,nens))

priors = [(d0min,d0max),(d1min,d1max),(d2min,d2max),(d3min,d3max),
          (y1min,y1max),(y2min,y2max),(y3min,y3max)]
predict_samples = np.array(predict_priors).T
</code></pre>

<p>We need to create new log prior, log likelihood, and log posterior functions. This is done almost exactly as above, but with very slight variations, so I'll won't go into detail about the machinery in these functions.</p>
<pre><code class="python">def loglike_predict(theta, times, obs):
    &quot;&quot;&quot;
    Function to return the log likelihood, given the current parameters, dates, and sunspot counts
    &quot;&quot;&quot;
    # expected value found by predicting new parameters, and then mimicking old likelihood function
    params_new = predict_cycle(param_mu, *theta)
    lmbda = np.array(cycle(times, *params_new))
    n = len(obs)
    a = np.sum(gammaln(np.array(obs)+1))
    b = np.sum(np.array(obs) * np.log(lmbda))
    return -np.sum(lmbda) - a + b

def logprior_predict(theta):
    &quot;&quot;&quot;
    Function to return the log of the prior, given set of current parameters
    &quot;&quot;&quot;
    lprior = 0
    for i in range(len(predict_priors)):
        # sum log priors from each parameter
        low, up = priors[i][0],priors[i][1]            
        # uniform prior for time parameters
        if  low &lt; theta[i] &lt; up: 
            pass
        else:
            lprior = -np.inf

    return lprior

def logposterior_predict(theta, times, obs):
    &quot;&quot;&quot;
    Function to return the log posterior, given the log prior and log likelihood
    &quot;&quot;&quot;
    lprior = logprior_predict(theta)
    # check log prior is finite
    if not np.isfinite(lprior):
        return -np.inf
    return lprior + loglike_predict(theta, times, obs)
</code></pre>

<p>Running the sampler, using the same burn-in and chain lengths as above, we can tune the parameters so they predict the parameters of the second solar cycle well. We'll then assume that these parameters are the same for the third and fourth peaks, and see how good the quality of the fit is with increasing forecast time.</p>
<pre><code class="python">sampler = zeus.sampler(nens, ndims, logposterior_predict, args=[peaktimes[1], peaks[1]])

nburn = 500
nsamples = 500

time0 = time()
sampler.run_mcmc(predict_samples, nburn + nsamples)
time1 = time()

print(&quot;Time taken to sample predict function with Zeus: {} seconds&quot;.format(time1-time0))
</code></pre>

<pre><code>Initialising ensemble of 100 walkers...
Sampling progress : 100%|██████████| 1000/1000 [01:19&lt;00:00, 12.56it/s]

Time taken to sample predict function with Zeus: 79.66238069534302 seconds
</code></pre>
<h3 id="predictions">Predictions</h3>
<p>Out of curiosity, we can check the corner plot for the prediction model. Since the prediction model has every parameter interacting with eachother, we can expect a load of covariance between parameters.</p>
<pre><code class="python">samples_zeus2 = sampler.get_chain(flat=True, discard=nburn)

predict_param_mu = [np.mean(samples_zeus2[:,i]) for i in range(7)]
predict_param_sig = [np.std(samples_zeus2[:,i]) for i in range(7)]

nfits = 300
predict_param_samples = [np.random.choice(samples_zeus2[:,i],nfits) for i in range(7)]
predict_post_samples = np.array(predict_param_samples).T

labels = ['d0','d1','d2','d3','y1', 'y2', 'y3']
plotposts(samples_zeus2,labels)
</code></pre>

<p><img alt="png" src="../output_47_0.png" /></p>
<p>Lets check what predictions we can now make. The below code takes the set of parameters describing the first solar cycle, and uses it to predict the second solar cycle. The prediction will be plotted over the data, and then the program will move on to the next peak and repeat the process. Since we're making predictions on using predictions, over and over, we can expect the fit to get worse as we look deeper into the future.</p>
<p>I'll also use the samples from the prediction model posteriors, and create a posterior predictive plot for each cycle. This should show the quality of the prediction, and how it evolves with increasing forecast time.</p>
<pre><code class="python">fig,axs = plt.subplots(3,2,figsize=(10,10))

# predict second peak parameters
# plot mean posterior plot
new_param_mu = predict_cycle(param_mu,*predict_param_mu)
axs[0,0].plot(peaktimes[1],peaks[1])
x = np.linspace(min(peaktimes[1]),max(peaktimes[1]),300)
axs[0,0].plot(x,cycle(x,*new_param_mu))
axs[0,0].set_ylabel(&quot;Square Root of Sunspot Number&quot;)
axs[0,0].set_title(&quot;Average sunspot number for the solar cycles\n between 1933-1965&quot; + 
              &quot; with overfitted\n mean predicted models&quot;)
# posterior predictive plot
axs[0,1].plot(peaktimes[1],peaks[1])
new_pred = []
for i in range(len(predict_post_samples)):
    pred = predict_cycle(param_mu,*predict_post_samples[i])
    new_pred.append(pred)
    y = cycle(x,*pred)
    axs[0,1].plot(x,y,&quot;orange&quot;,alpha=0.04,linewidth=3)
axs[0,1].set_title(&quot;Average sunspot number for the solar cycles\n between 1933-1965&quot; + 
              &quot; with overfitted\n posterior predictive plots&quot;)


# predict third peak parameters 
# plot mean posterior plot
new_param_mu = predict_cycle(new_param_mu, *predict_param_mu)
axs[1,0].plot(peaktimes[2],peaks[2])
x = np.linspace(min(peaktimes[2]),max(peaktimes[2]),300)
axs[1,0].plot(x,cycle(x,*new_param_mu))
axs[1,0].set_ylabel(&quot;Square Root of Sunspot Number&quot;)
axs[1,0].set_xlabel(&quot;Date / years&quot;)
# posterior predictive plot
axs[1,1].plot(peaktimes[2],peaks[2])
new_pred2 = []
for i in range(len(predict_post_samples)):
    pred = predict_cycle(new_pred[i],*predict_param_mu)
    new_pred2.append(pred)
    y = cycle(x,*pred)
    axs[1,1].plot(x,y,&quot;orange&quot;,alpha=0.04,linewidth=3)

# predict fourth peak parameters
# plot mean posterior plot
new_param_mu = predict_cycle(new_param_mu, *predict_param_mu)
axs[2,0].plot(peaktimes[3],peaks[3],label=&quot;Original Data&quot;)
x = np.linspace(min(peaktimes[3]),max(peaktimes[3]),300)
axs[2,0].plot(x,cycle(x,*new_param_mu),label=&quot;Predicted Model&quot;)
axs[2,0].set_ylabel(&quot;Square Root of Sunspot Number&quot;)
axs[2,0].set_xlabel(&quot;Date / years&quot;)
axs[2,0].legend()
# posterior predictive plot
axs[2,1].plot(peaktimes[3],peaks[3])
for i in range(len(predict_post_samples)):
    pred = predict_cycle(new_pred2[i],*predict_param_mu)
    y = cycle(x,*pred)
    axs[2,1].plot(x,y,&quot;orange&quot;,alpha=0.04,linewidth=3)
axs[2,1].set_xlabel(&quot;Date / years&quot;)
plt.show()
</code></pre>

<p><img alt="png" src="../output_49_0.png" /></p>
<p>Saying that our prediction model was fairly simplified, it actually does a pretty good job at predicting the solar cycle shape. The posterior plots show the predictions getting worse over time as expected, but even so the accuracy on the mean plots are within 20% for the majority of the cycles.</p>
<h2 id="modelling-with-nestle">Modelling with Nestle</h2>
<p>The predictions from this model only work if we know in advance that the next solar cycle will carry on the trend from the previous solar cycle. Since in reality it is very hard to say how the Sun will behave in advance, this model won't be all that useful.</p>
<p>However, it did save us from having to individually sampling 3 solar cycles. To decide whether or not the time save is worth the loss in accuracy, I'll use "Nestle" to sample both the second solar cycle (between 1934-1945), and the prediction model for that same solar cycle. Nestle uses nested sampling, and so it produces a value of the marginalised evidence. Comparing these values will allow us to see how much accuracy we're sacrificing by predicting the solar cycle, instead of just sampling the next peak.</p>
<h3 id="sampling-the-data_1">Sampling the data</h3>
<p>To start, we'll assume that Zeus did a good enough job at sampling the first solar cycle, and jump straight to the second cycle (1934-1945). Lets define some new guesses for each parameter (c,a1,a2,t0,tmax,t1):</p>
<pre><code class="python"># mean and standard deviation of normal parameter priors
cmu,csig = 13,1
# lower and upper bounds of uniform parameter priors
a1min,a1max = 1,3
a2min,a2max = 1,3
t0min,t0max = 1931,1935
tmaxmin,tmaxmax = 1936,1940
t1min,t1max = 1943,1947

param_priors = [(cmu,csig),(a1min,a1max),(a2min,a2max),
                (t0min,t0max),(tmaxmin,tmaxmax),(t1min,t1max)]
</code></pre>

<p>We can reuse most of the stuff we had from before, except for the log prior functions. Nestle samples from a unit hypercube parameter space, so we need a function that transforms the priors back to their original space. This only requires a slight modification to our previous "logprior" function, making use of scipy's ndtri function. </p>
<p>I'll also make a very minor change to the log likelihood function. Instead of taking the dates and sunspot counts as arguments, it will use the data for the second solar cycle by default.</p>
<pre><code class="python">def prior_transform(theta):
    &quot;&quot;&quot;
    Function to transform the parameters from unit hypercube to their true form
    &quot;&quot;&quot;
    trans_params = []
    # transform normal prior
    trans_params.append(param_priors[0][0] + param_priors[0][1]*ndtri(theta[0]))
    # transform uniform prior
    for i in range(1,6):
        mini, maxi = param_priors[i][0], param_priors[i][1]
        trans_params.append(theta[i]*(maxi-mini) + mini)

    return trans_params

def loglike_nestle(theta):
    &quot;&quot;&quot;
    Function to return the log likelihood, with data fixed for solar cycle between 1934-1945
    &quot;&quot;&quot;
    obs, times = peaks[1], peaktimes[1] 
    # unpack parameters
    c_like, a1_like, a2_like, t0_like, tmax_like, t1_like = theta
    # expected value
    lmbda = np.array(cycle(times, c_like, a1_like, a2_like, t0_like, tmax_like, t1_like))
    n = len(obs)
    a = np.sum(gammaln(np.array(obs)+1))
    b = np.sum(np.array(obs) * np.log(lmbda))
    return -np.sum(lmbda) - a + b
</code></pre>

<p>We're now ready to run the sampling using Nestle:</p>
<pre><code class="python"># set number of dimensions, live points, sampling method, and stopping criterion
ndims = 6
nlive = 1024     
method = 'multi'        
stop = 0.1

time0 = time()
results_sample = nestle.sample(loglike_nestle, prior_transform, ndims,
                    method=method, npoints=nlive, dlogz=stop)
time1 = time()

print(&quot;Time taken to sample second solar cycle with Nestle: {} seconds&quot;.format(time1-time0))
</code></pre>

<pre><code>Time taken to sample second solar cycle with Nestle: 18.891968965530396 seconds
</code></pre>
<p>We'll now try the sampling again, but this time we'll use the parameters from the first solar cycle (found using Zeus), and sample the parameters of the prediction model. Start by guessing at the parameters for the prediction model:</p>
<pre><code class="python"># reuse our guesses from Zeus
d0min,d0max = -2.,0
d1min,d1max = -1.,1.
d2min,d2max = -1.,0.
d3min,d3max = 0.,0.4
y1min,y1max = 7.,8.
y2min,y2max = 0.2,0.8
y3min,y3max = 0.25,0.75

predict_priors = [(d0min,d0max),(d1min,d1max),(d2min,d2max),(d3min,d3max),
               (y1min,y1max),(y2min,y2max),(y3min,y3max)]
</code></pre>

<p>We have to tinker with out prediction model's likelihood and prior functions. This is done exactly as it was previously.</p>
<pre><code class="python">def loglike_nestle_predict(theta):
    &quot;&quot;&quot;
    Function to return the log likelihood, given the current parameters, dates, and sunspot counts
    &quot;&quot;&quot;
    obs,times = peaks[1],peaktimes[1]
    # expected value found by predicting new parameters, and then mimicking old likelihood function
    params_new = predict_cycle(param_mu, *theta)
    lmbda = np.array(cycle(times, *params_new))
    n = len(obs)
    a = np.sum(gammaln(np.array(obs)+1))
    b = np.sum(np.array(obs) * np.log(lmbda))
    return -np.sum(lmbda) - a + b

def prior_transform_predict(theta):
    &quot;&quot;&quot;
    Function to return the log of the prior, given set of current parameters
    &quot;&quot;&quot;
    trans_priors = []
    for i in range(len(predict_priors)):
        # sum log priors from each parameter
        mini, maxi = predict_priors[i][0],predict_priors[i][1]            
        # uniform prior for time parameters
        trans_priors.append(theta[i]*(maxi-mini)+mini)

    return trans_priors
</code></pre>

<p>Now that everything is set up, I'll run through the same sampling process, using the same hyper-parameters for fairness.</p>
<pre><code class="python"># set number of dimensions, live points, sampling method, and stopping criterion
ndims = 7
nlive = 1024     
method = 'multi'        
stop = 0.1

time0 = time()
results_predict = nestle.sample(loglike_nestle_predict, prior_transform_predict, ndims,
                    method=method, npoints=nlive, dlogz=stop)
time1 = time()

print(&quot;Time taken to sample prediction model with Nestle: {} seconds&quot;.format(time1-time0))
</code></pre>

<pre><code>Time taken to sample prediction model with Nestle: 13.779999017715454 seconds
</code></pre>
<h3 id="results_1">Results</h3>
<p>Next, we find the log of the marginalised evidence provided by Nestle. This can be done as follows, using the information gain to estimate the error:</p>
<pre><code class="python">logZ_sample = results_sample.logz
logZerr_sample = np.sqrt(results_sample.h/nlive) 

logZ_predict = results_predict.logz
logZerr_predict = np.sqrt(results_predict.h/nlive) 

print(&quot;log(Z) from sampling the solar cycle = {} ± {}&quot;.format(logZ_sample, logZerr_sample))
print(&quot;log(Z) from predicting the solar cycle = {} ± {}&quot;.format(logZ_predict, logZerr_predict))
</code></pre>

<pre><code>log(Z) from sampling the solar cycle = -266.75746256813557 ± 0.07494693736170717
log(Z) from predicting the solar cycle = -266.81473144676227 ± 0.07314472974917986
</code></pre>
<p>The Bayes factor is a metric that describes how much more likely a model is to produce an observed data set. It's defined as the ratios between the marginalised evidences of the two models:</p>
<pre><code class="python">K = np.exp(logZ_predict - logZ_sample)
print(&quot;Bayes factor: {}&quot;.format(K))
</code></pre>

<pre><code>Bayes factor: 0.9443401223523545
</code></pre>
<p>This tells us that sampling via the prediction method rather than just sampling the peak doesn't come at a cost to the quality of the model. Since the methods produce simillar results, lets collect the samples from the prediction method to use for visualising our results. Since Nestle uses nested sampling, we have to resample with weights to obtain the posteriors.</p>
<pre><code class="python">weights = results_predict.weights/np.max(results_predict.weights)
mask = np.where(np.random.rand(len(weights)) &lt; weights)[0]
# collect posterior samples
samples_nestle = results_predict.samples[mask,:]
# collect posterior means
predict_param_mu_nestle = [np.mean(samples_nestle[:,i]) for i in range(7)]
# collect samples for posterior predictive plot
nfits = 300
predict_param_samples_nestle = [np.random.choice(samples_nestle[:,i],nfits) for i in range(7)]
predict_post_samples_nestle = np.array(predict_param_samples).T
</code></pre>

<h3 id="plotting-the-posterior_1">Plotting the posterior</h3>
<p>Let's start by making a comparison between the posteriors from Zeus and Nestle. Below I'll create two plots. The first will show the mean posterior predictions of the second solar cycle, from both Zeus and Nestle. The second plot will show the posterior predictive plots, for both samplers also.</p>
<pre><code class="python">fig,(ax1,ax2) = plt.subplots(1,2,figsize=(13,4))

# plot mean posterior plot
new_param_mu_zeus = predict_cycle(param_mu,*predict_param_mu)
new_param_mu_nestle = predict_cycle(param_mu,*predict_param_mu_nestle)
ax1.plot(peaktimes[1],peaks[1],label=&quot;Original Data&quot;)
x = np.linspace(min(peaktimes[1]),max(peaktimes[1]),300)
ax1.plot(x,cycle(x,*new_param_mu_zeus),&quot;orange&quot;,label=&quot;Zeus Prediction&quot;)
ax1.plot(x,cycle(x,*new_param_mu_nestle),&quot;purple&quot;,label=&quot;Nestle Prediction&quot;)
ax1.set_ylabel(&quot;Square Root of Sunspot Number&quot;)
ax1.set_xlabel(&quot;Date / years&quot;)
ax1.set_title(&quot;Average sunspot number for the solar cycles\n between 1934-1945&quot; + 
              &quot; with overfitted\n mean predicted models&quot;)
ax1.legend()

# posterior predictive plot
ax2.plot(peaktimes[1],peaks[1])
for i in range(len(predict_post_samples)):
    pred = predict_cycle(param_mu,*predict_post_samples[i])
    y = cycle(x,*pred)
    ax2.plot(x,y,&quot;orange&quot;,alpha=0.04,linewidth=3)

    pred = predict_cycle(param_mu,*(np.array(predict_post_samples_nestle[i])+0.01))
    y = cycle(x,*pred)
    ax2.plot(x,y,&quot;purple&quot;,alpha=0.04,linewidth=3)
ax1.set_ylabel(&quot;Date / years&quot;)
ax2.set_title(&quot;Average sunspot number for the solar cycles\n between 1934-1945&quot; + 
              &quot; with overfitted\n posterior predictive plots&quot;)
plt.show()
</code></pre>

<p><img alt="png" src="../output_75_0.png" /></p>
<p>Whilst the posterior predictive plot looks a little messy, it tells us that the posterior predictives from Zeus and Nestle are difficult to tell apart, since they overlap so much. The mean posterior plot supports this, showing that the two samplers have no deviation over the entire cycle.</p>
<p>Finally, lets plot a posterior predictive plot that shows the evolution of the prediction accuracy over time. Below is a plot that shows predictions for the entire range of 4 solar cycles between 1923 and 1965.</p>
<pre><code class="python">plt.figure(figsize=(14,4))
# plot data between 1923 and 1965
plt.plot(dates[start:start + 4*period],sqrtssn[start:start + 4*period],label=&quot;Original Data&quot;)

# plot first cycle posterior predictive, using Zeus samples
x = np.linspace(min(peaktimes[0])-20,max(peaktimes[0]),300)
for i in range(len(post_samples)):
    params = post_samples[i]
    y = cycle(x,*params)
    plt.plot(x,y,&quot;purple&quot;,alpha=0.02, linewidth=3,label=&quot;Fitted Model&quot; if i == 0 else &quot;&quot;)

# use first cycle posterior predictive to find second cycle posterior predictive
new_pred = []
x = np.linspace(min(peaktimes[1])-20,max(peaktimes[1])+20,300)
for i in range(len(predict_post_samples_nestle)):
    pred = predict_cycle(param_mu,*predict_post_samples_nestle[i])
    new_pred.append(pred)
    y = cycle(x,*pred)
    plt.plot(x,y,&quot;orange&quot;,alpha=0.04,linewidth=3,label=&quot;Predicted Model&quot; if i == 0 else &quot;&quot;)

# use second cycle posterior predictive to find third cycle posterior predictive
x = np.linspace(min(peaktimes[2])-20,max(peaktimes[2])+20,300)
new_pred2 = []
for i in range(len(predict_post_samples_nestle)):
    pred = predict_cycle(new_pred[i],*predict_param_mu_nestle)
    new_pred2.append(pred)
    y = cycle(x,*pred)
    plt.plot(x,y,&quot;orange&quot;,alpha=0.04,linewidth=3)

# use third cycle posterior predictive to find fourth cycle posterior predictive
x = np.linspace(min(peaktimes[3])-20,max(peaktimes[3])+20,300)
for i in range(len(predict_post_samples)):
    pred = predict_cycle(new_pred2[i],*predict_param_mu_nestle)
    y = cycle(x,*pred)
    plt.plot(x,y,&quot;orange&quot;,alpha=0.04,linewidth=3)

plt.xlabel(&quot;Date / years&quot;)
plt.ylabel(&quot;Square Root of Sunspot Number&quot;)
plt.title(&quot;Predictions of average sunspot number between 1934-1965,\n&quot; + 
          &quot; using the cycle between 1923-1934 to make predictions&quot;)

plt.xlim(1923,1967)
plt.ylim(1)

leg = plt.legend(loc=&quot;upper left&quot;)
for lh in leg.legendHandles: 
    lh.set_alpha(1)

plt.show()
</code></pre>

<p><img alt="png" src="../output_77_0.png" /></p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../../LightCurve/LightCurve/" title="Exoplanet Light Curve Analysis with emcee and UltraNest" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Exoplanet Light Curve Analysis with emcee and UltraNest
              </div>
            </div>
          </a>
        
        
          <a href="../../gravwaves/gravwaves/" title="Gravitational Wave parameter estimation with bilby" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Gravitational Wave parameter estimation with bilby
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.92ffa368.min.js"></script>
      <script src="../../assets/javascripts/bundle.5123e3d4.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.a68abb33.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>